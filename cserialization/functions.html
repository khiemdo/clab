<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<title>C serialization library: Function reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="author" content="Ulf &Aring;str&ouml;m" />
<meta name="keywords" content="c serialize serialization deflation inflation conversion translation" />
<meta name="description" content="Function reference for C serialization library." /><html>

<link type="text/css" rel="stylesheet" href="_manual.css" />

</head>

<body><h1><span class="red">C serialization library: Function reference</span></h1>
<p>See also: <a href="readme.html">README</a></p><div id="toc">
<h4>Translators</h4><ul>
<li><a href="#ser_new_tra">ser_new_tra</a></li><li><a href="#ser_del_tra">ser_del_tra</a></li><li><a href="#ser_new_dyn_array">ser_new_dyn_array</a></li><li><a href="#ser_new_nullterm_array">ser_new_nullterm_array</a></li><li><a href="#ser_meta_tra">ser_meta_tra</a></li><li><a href="#ser_tra_list">ser_tra_list</a></li><li><a href="#ser_find_tra">ser_find_tra</a></li></ul>
<h4>Fields</h4><ul>
<li><a href="#ser_new_field">ser_new_field</a></li><li><a href="#ser_del_field">ser_del_field</a></li><li><a href="#ser_find_field">ser_find_field</a></li></ul>
<h4>Serialization</h4><ul>
<li><a href="#ser_ialize">ser_ialize</a></li><li><a href="#ser_parse">ser_parse</a></li></ul>
<h4>Logging</h4><ul>
<li><a href="#ser_def_log">ser_def_log</a></li><li><a href="#ser_null_log">ser_null_log</a></li></ul>
<h4>Strings</h4><ul>
<li><a href="#ser_preformat">ser_preformat</a></li><li><a href="#ser_escape_str">ser_escape_str</a></li><li><a href="#ser_unescape_str">ser_unescape_str</a></li><li><a href="#ser_hex2char">ser_hex2char</a></li></ul>
<h4>Types</h4><ul>
<li><a href="#ser_is_signed">ser_is_signed</a></li><li><a href="#ser_field_size">ser_field_size</a></li><li><a href="#ser_is_primitive">ser_is_primitive</a></li><li><a href="#ser_valid_type">ser_valid_type</a></li></ul>
<h4>Internal</h4><ul>
<li><a href="#ser_nullterm_len">ser_nullterm_len</a></li><li><a href="#ser_list_holders">ser_list_holders</a></li><li><a href="#ser_ptr_overlap">ser_ptr_overlap</a></li><li><a href="#ser_job_realloc_result">ser_job_realloc_result</a></li><li><a href="#ser_job_cat">ser_job_cat</a></li><li><a href="#ser_assign_holder">ser_assign_holder</a></li><li><a href="#ser_find_holder">ser_find_holder</a></li><li><a href="#ser_write_primitive">ser_write_primitive</a></li><li><a href="#ser_dump">ser_dump</a></li><li><a href="#ser_write_struct">ser_write_struct</a></li><li><a href="#ser_set_holder_elements">ser_set_holder_elements</a></li><li><a href="#ser_element_count">ser_element_count</a></li><li><a href="#ser_write_array">ser_write_array</a></li><li><a href="#ser_set_custom_handler">ser_set_custom_handler</a></li><li><a href="#ser_numeric_cast">ser_numeric_cast</a></li><li><a href="#ser_find_array_count">ser_find_array_count</a></li><li><a href="#ser_follow_ptrs">ser_follow_ptrs</a></li><li><a href="#ser_write_value">ser_write_value</a></li><li><a href="#ser_job_realloc_holders">ser_job_realloc_holders</a></li><li><a href="#ser_clear_holder">ser_clear_holder</a></li><li><a href="#ser_read_primitive">ser_read_primitive</a></li><li><a href="#ser_resolve_subst_ptr">ser_resolve_subst_ptr</a></li><li><a href="#ser_check_subst_ptrs">ser_check_subst_ptrs</a></li><li><a href="#ser_add_subst_ptr">ser_add_subst_ptr</a></li><li><a href="#ser_restore_pointers">ser_restore_pointers</a></li><li><a href="#ser_restore_ptr">ser_restore_ptr</a></li><li><a href="#ser_replace_ptr">ser_replace_ptr</a></li><li><a href="#ser_read_struct">ser_read_struct</a></li><li><a href="#ser_read_struct_internal">ser_read_struct_internal</a></li><li><a href="#ser_expect">ser_expect</a></li><li><a href="#ser_read_value">ser_read_value</a></li><li><a href="#ser_ntok">ser_ntok</a></li><li><a href="#ser_field_by_offset">ser_field_by_offset</a></li><li><a href="#ser_blank_struct">ser_blank_struct</a></li><li><a href="#ser_token_code">ser_token_code</a></li></ul>
</div>
<h2><span class="red">Translators</span></h2>
<span class="function"><h3><a name="ser_new_tra">ser_tra_t * ser_new_tra(const char * id, const size_t size, ser_tra_t * att)</a></h3></span>
<p class="funcdesc">Makes a new translator called <strong>id</strong> for a structure <strong>size</strong> bytes large. If <strong>att</strong> is non-NULL the new translator will be attached to the end of that list of translators. <br/><br/> Returns a pointer to the new translator or NULL on error.</p>
<span class="function"><h3><a name="ser_del_tra">void ser_del_tra(ser_tra_t * tra)</a></h3></span>
<p class="funcdesc">Deletes the translator <strong>tra</strong> and all translators linked after it.</p>
<span class="function"><h3><a name="ser_new_dyn_array">ser_tra_t * ser_new_dyn_array(const char * id, const char * type,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int ref, const size_t size, ser_tra_t * att)</a></h3></span>
<p class="funcdesc">Makes a new translator called <strong>id</strong> that will be a dynamic (variable-size, i.e. a pointer) array of <strong>type</strong>. If <strong>att</strong> is non-NULL the new translator will be attached to the end of that list of translators. <br/><br/> Note: other translators referencing <strong>id</strong> needs an array count field to function properly. <br/><br/> Returns a pointer to the new translator or NULL on error.</p>
<span class="function"><h3><a name="ser_new_nullterm_array">ser_tra_t * ser_new_nullterm_array(const char * id, const char * type,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int ref, ser_tra_t * att)</a></h3></span>
<p class="funcdesc">Makes a new translator called <strong>id</strong> that will be a null-terminated array of <strong>type</strong>. If <strong>att</strong> is non-NULL the new translator will be attached to the end of that list of translators. <br/><br/> Returns a pointer to the new translator or NULL on error.</p>
<span class="function"><h3><a name="ser_meta_tra">char * ser_meta_tra(ser_tra_t * tra)</a></h3></span>
<p class="funcdesc">Serializes translators. This function sets up translators for ser_tra_t and ser_field_t; i.e. it describes the structure of the translators themselves. If <strong>tra</strong> is provided the translators in this list will be serialized, otherwise the meta translators will be serialized. <br/><br/> Returns the serialized translator(s).</p>
<span class="function"><h3><a name="ser_tra_list">void ser_tra_list(ser_tra_t * tra)</a></h3></span>
<p class="funcdesc">Prints (to stderr) the fields in <strong>tra</strong> and all linked translators.</p>
<span class="function"><h3><a name="ser_find_tra">ser_tra_t * ser_find_tra(ser_tra_t * tra, const char * id)</a></h3></span>
<p class="funcdesc">Given the linked list of translators <strong>tra,</strong> finds the one called <strong>id</strong>.</p>
<h2><span class="red">Fields</span></h2>
<span class="function"><h3><a name="ser_new_field">ser_field_t * ser_new_field(ser_tra_t * tra, const char * type, const int ref,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * tag, const size_t offset)</a></h3></span>
<p class="funcdesc">Adds field <strong>tag</strong> to the translator <strong>tra</strong>. The field will be serialized as <strong>type</strong>. If <strong>ref</strong> is non-zero it will be made a reference. <strong>offset</strong> is the number of bytes between the start of the structure and the start of the member field; it is recommended to find this using offsetof(). <br/><br/> The field will not be created if a field with the same tag exists in the translator or if the translator is defined as an array, i.e. it was created with ser_new_dyn_array() or ser_new_null_array() (see ser_tra_t.atype). <br/><br/> Returns a pointer to the new field, or NULL on error.</p>
<span class="function"><h3><a name="ser_del_field">void ser_del_field(ser_tra_t * tra, ser_field_t * field)</a></h3></span>
<p class="funcdesc">Deletes <strong>field</strong> from <strong>tra</strong> and all fields linked after it.</p>
<span class="function"><h3><a name="ser_find_field">ser_field_t * ser_find_field(ser_tra_t * tra, const char * id, const  char * tag)</a></h3></span>
<p class="funcdesc">Given the translator list <strong>tra</strong>, looks up field <strong>tag</strong> in translator <strong>id</strong>. <br/><br/> Returns a pointer to the field or NULL if it could not be found. Both translator <strong>id</strong> and field <strong>tag</strong> must match; if there is another translator with the same field tag it will not be detected.</p>
<h2><span class="red">Serialization</span></h2>
<span class="function"><h3><a name="ser_ialize">char * ser_ialize(ser_tra_t * tra, char * type, void * first,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*log_func)(char *), uint16_t options)</a></h3></span>
<p class="funcdesc">Serializes <strong>first</strong> as <strong>type,</strong> using <strong>tra</strong> as translator list (a translator for <strong>type</strong> must exist in <strong>tra).</strong> Extra options can be given as a bitmask in <strong>options</strong>; see SER_OPT_* for details. <br/><br/> If <strong>log_func</strong> is provided it will be called with error messages if serialization fails. If it is NULL output will be muted. See ser_def_log(). Implement your own to redirect output to a custom logging console, etc. <br/><br/> Returns a string (which must be freed after use) describing the structure in human-readable format. Returns NULL on error.</p>
<span class="function"><h3><a name="ser_parse">void * ser_parse(ser_tra_t * first_tra, const char * expected_type,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char * s, void (*log_func)(char*))</a></h3></span>
<p class="funcdesc">Parses (inflates) <strong>s</strong> according to the translator list <strong>first_tra.</strong> <strong>expected_type</strong> should specify the type to expect for index #1; if it differs the process will fail. <br/><br/> If <strong>log_func</strong> is provided it will be called with error messages if inflation fails. If it is NULL output will be muted. See ser_def_log(). <br/><br/> Returns a pointer to element #1 (correspondingly passed as <strong>first</strong> to ser_ialize()) or NULL on failure.</p>
<h2><span class="red">Logging</span></h2>
<span class="function"><h3><a name="ser_def_log">void ser_def_log(char * msg)</a></h3></span>
<p class="funcdesc">Default error logger. Implement your own and pass it to ser_ialize() and ser_parse() to redirect errors to your custom logging console, message boxes, etc.</p>
<span class="function"><h3><a name="ser_null_log">void ser_null_log(char * msg)</a></h3></span>
<p class="funcdesc">Discards messages. This is where "muted" output ends up.</p>
<h2><span class="red">Strings</span></h2>
<span class="function"><h3><a name="ser_preformat">char * ser_preformat(char * s)</a></h3></span>
<p class="funcdesc">Creates a copy of <strong>s</strong> suitable for ser_parse. Semicolons, commas, braces outside quotes will be padded with spaces. <br/><br/> Returns the padded string or NULL on error.</p>
<span class="function"><h3><a name="ser_escape_str">char * ser_escape_str(char * s)</a></h3></span>
<p class="funcdesc">Creates a copy of <strong>s</strong> with quotes, backslashes and non-printable characters preceded by backslashes. Newline characters (ASCII 10) will be represented as \n, quotes as \", backslashes as \\ and non-printable characters as \xnn, where nn are hexadecimal digits. <br/><br/> Returns the escaped string or NULL on error.</p>
<span class="function"><h3><a name="ser_unescape_str">char * ser_unescape_str(char * s)</a></h3></span>
<p class="funcdesc">Creates a copy of <strong>s</strong> with escaped characters converted back to their real values; reverse of ser_escape_str. <br/><br/> Returns the restored string or NULL on error.</p>
<span class="function"><h3><a name="ser_hex2char">char ser_hex2char(char * s)</a></h3></span>
<p class="funcdesc">Converts two hexadecimal digits to a number. <strong>s</strong> should point to a string with two characters 0-F (case insensitive); these will be converted to a value in the 0-255 range. <br/><br/> Returns the converted value.</p>
<h2><span class="red">Types</span></h2>
<span class="function"><h3><a name="ser_is_signed">bool ser_is_signed(const char * type)</a></h3></span>
<p class="funcdesc">Checks if <strong>type</strong> is a signed numeric type.</p>
<span class="function"><h3><a name="ser_field_size">size_t ser_field_size(ser_job_t * job, const char * type, const int ref)</a></h3></span>
<p class="funcdesc">Returns the size (in bytes) of <strong>type</strong>. If <strong>ref</strong> is nonzero it will instead return the size of a pointer to such an array (which really will be sizeof(void*)).</p>
<span class="function"><h3><a name="ser_is_primitive">bool ser_is_primitive(const char * s)</a></h3></span>
<p class="funcdesc">Returns if <strong>s</strong> is a type that can be serialized natively (without a user-provided translator).</p>
<span class="function"><h3><a name="ser_valid_type">bool ser_valid_type(ser_tra_t * tra, char * s)</a></h3></span>
<p class="funcdesc">Returns if <strong>s</strong> is a valid type (primitive or present as a translator in translator list <strong>tra</strong>).</p>
<h2><span class="red">Internal</span></h2>
<span class="function"><h3><a name="ser_nullterm_len">size_t ser_nullterm_len(void * thing, char * type)</a></h3></span>
<p class="funcdesc">Returns the length of a null-terminated array of <strong>type</strong> starting at <strong>thing</strong>. Elements will be counted up to (and including) the first that is zero.</p>
<span class="function"><h3><a name="ser_list_holders">void ser_list_holders(ser_job_t * job)</a></h3></span>
<p class="funcdesc">Lists the holders in <strong>job</strong>; what they point to, size, type, element count, redirections, etc.</p>
<span class="function"><h3><a name="ser_ptr_overlap">void ser_ptr_overlap(ser_job_t * job)</a></h3></span>
<p class="funcdesc">Scans <strong>job</strong> for holders whose pointers overlap. If a holder is found whose destination would fit within a another structure, it will be marked as a redirected structure. This information will be used by ser_ialize(). <br/><br/> Returns non-zero on success, zero on failure.</p>
<span class="function"><h3><a name="ser_job_realloc_result">bool ser_job_realloc_result(ser_job_t * job, const int len)</a></h3></span>
<p class="funcdesc">Reallocates <strong>job</strong>s output buffer to <strong>len</strong> characters. One extra byte will be reserved for the terminator; this does not need to be included in <strong>len</strong>. <br/><br/> Returns true on success, false on failure.</p>
<span class="function"><h3><a name="ser_job_cat">bool ser_job_cat(ser_job_t * job, char * s)</a></h3></span>
<p class="funcdesc">Concatenates <strong>s</strong> to <strong>job</strong>s result buffer. Note that the buffer might be moved and old pointers to it invalidated. <br/><br/> Returns true on success, false on failure (bad pointers, memory could not be allocated, etc).</p>
<span class="function"><h3><a name="ser_assign_holder">size_t ser_assign_holder(ser_job_t * job, void * thing, size_t size)</a></h3></span>
<p class="funcdesc">Finds the index of <strong>thing</strong> in <strong>job</strong>s list of pointer holders, or adds it if it isn't found. If the list is too small to hold the addition it will be resized aggressively. <br/><br/> Returns the index assigned or 0 on error.</p>
<span class="function"><h3><a name="ser_find_holder">size_t ser_find_holder(ser_job_t * job, void * thing, size_t size)</a></h3></span>
<p class="funcdesc">Returns the index of the holder in <strong>job</strong> pointing to <strong>thing</strong>, or 0 if it could not be found. <br/><br/> See also: ser_assign_holder</p>
<span class="function"><h3><a name="ser_write_primitive">bool ser_write_primitive(ser_job_t * job, const size_t holder,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * type, void * field_ptr)</a></h3></span>
<p class="funcdesc">Serializes a primitive value and adds it to <strong>job</strong>s output buffer. <strong>holder</strong> is the index of the value; <strong>type</strong> is self-explanatory and <strong>field_ptr</strong> is the start of the memory to be translated. <br/><br/> Returns true on success, false on failure.</p>
<span class="function"><h3><a name="ser_dump">bool ser_dump(ser_job_t * job, char * type, void * thing)</a></h3></span>
<p class="funcdesc">Converts <strong>thing</strong> to human-readable text, according to the translator for <strong>type</strong> present in <strong>job.</strong> The result will be appended to the output buffer in <strong>job.</strong> <br/><br/> Returns true if <strong>thing</strong> could be translated properly, false if something went wrong.</p>
<span class="function"><h3><a name="ser_write_struct">bool ser_write_struct(ser_job_t * job, ser_tra_t * tra,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t ptr_index, void * thing, const int anon)</a></h3></span>
<p class="funcdesc">Adds to <strong>job</strong>s output buffer a textual representation of the structure located at <strong>thing</strong> serialized using <strong>tra</strong>. <br/><br/> <strong>ptr_index</strong> should be the index of the holder pointing to <strong>thing</strong> or zero if <strong>thing</strong> does not have any memory allocation of its own (e.g. it is an anonymous sub-structure). <br/><br/> Returns true if everything went o-kay, false if something broke.</p>
<span class="function"><h3><a name="ser_set_holder_elements">bool ser_set_holder_elements(ser_job_t * job, size_t holder_index, size_t elements)</a></h3></span>
<p class="funcdesc">Sets the number of elements for holder <strong>holder_index</strong> in <strong>job</strong> to <strong>elements</strong>. <br/><br/> Returns true on success, false on error (in which case <strong>holder_index</strong> was probably outside the allocated range).</p>
<span class="function"><h3><a name="ser_element_count">bool ser_element_count(ser_job_t * job, ser_tra_t * tra,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ser_field_t * field, void * thing, void * start)</a></h3></span>
<p class="funcdesc">Looks for a holder in <strong>job</strong> that points to <strong>start</strong> and a field in <strong>tra</strong> that is the array count field of <strong>field</strong> (same name, prepended by an at sign). If both are found the holder element count will be set to the array count field value. <strong>thing</strong> is the structure referencing <strong>start</strong>; i.e. <strong>thing</strong> has one or more pointers to <strong>start</strong> that are also registered in the translator. <br/><br/> Returns true if the field was found and the holder count set, false if it could not be found or an error occured.</p>
<span class="function"><h3><a name="ser_write_array">bool ser_write_array(ser_job_t * job, ser_tra_t * tra, ser_field_t * field,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * array_start, size_t elements)</a></h3></span>
<p class="funcdesc">Writes <strong>elements</strong> fields, starting at <strong>array_start</strong>, to <strong>job</strong>s output buffer. <strong>tra</strong> should be the type of container structure and <strong>field</strong> the type of output. <br/><br/> Returns true if the array could be written, false on error.</p>
<span class="function"><h3><a name="ser_set_custom_handler">void ser_set_custom_handler(ser_tra_t * tra,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int (*func_ptr)(ser_job_t *, ser_tra_t *, void *))</a></h3></span>
<p class="funcdesc">Sets the custom output handler for <strong>tra</strong> to <strong>func_ptr</strong>. There can only be one such function per translator; if multiple calls are needed (for OO-like functionality) a wrapper function is needed.</p>
<span class="function"><h3><a name="ser_numeric_cast">long ser_numeric_cast(void * ptr, char * type)</a></h3></span>
<p class="funcdesc">Attempts to convert the data at <strong>ptr</strong> into a <strong>type</strong> number. No type or overflow checking is performed. <br/><br/> Returns the number (0 on error).</p>
<span class="function"><h3><a name="ser_find_array_count">ser_field_t * ser_find_array_count(ser_tra_t * tra, char * array_tag)</a></h3></span>
<p class="funcdesc">Returns a pointer to any field in <strong>tra</strong> that is an array count for <strong>array_tag;</strong> i.e. one that is <strong>array_tag</strong> prepended with a <strong>.</strong></p>
<span class="function"><h3><a name="ser_follow_ptrs">bool ser_follow_ptrs(ser_job_t * job, size_t holder_index,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ser_tra_t * thing_tra, void * thing)</a></h3></span>
<p class="funcdesc">Searches <strong>thing</strong> for reference fields and adds their destination to <strong>job</strong>s list of holders. If <strong>holder_index</strong> is non-zero the type specified for that holder will be used as translator, otherwise <strong>thing_tra</strong> must be provided. <br/><br/> Returns true on success, false on utter, catastrophic failure.</p>
<span class="function"><h3><a name="ser_write_value">bool ser_write_value(ser_job_t * job, const char * type,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int ref, void * field_ptr)</a></h3></span>
<p class="funcdesc">Appends to <strong>job</strong>s output buffer a textual representation of <strong>field_ptr</strong> as a <strong>type.</strong> If the field is a reference, it will also register in <strong>job</strong>s "holder" list what type of translation to use for the destination structure in the future. <br/><br/> Returns true if the value could be written properly, false on error.</p>
<span class="function"><h3><a name="ser_job_realloc_holders">bool ser_job_realloc_holders(ser_job_t * job, const int n)</a></h3></span>
<p class="funcdesc">Resizes the holder list of <strong>job</strong> to <strong>n</strong> elements. If the list is expanded, new entries will be cleared. <br/><br/> Returns true on success, false on failure.</p>
<span class="function"><h3><a name="ser_clear_holder">void ser_clear_holder(ser_holder_t * holder)</a></h3></span>
<p class="funcdesc">Clears <strong>holder</strong>. This will not free any pointers associated with it, only reset them to neutral values.</p>
<span class="function"><h3><a name="ser_read_primitive">bool ser_read_primitive(ser_job_t * job, const long id, const char * type)</a></h3></span>
<p class="funcdesc">Reads a primitive <strong>type</strong> from <strong>job</strong>s parse buffer. The result will be stored in holder <strong>id</strong> after allocating sufficient memory to stort the type. <br/><br/> Returns true on success, false on failure.</p>
<span class="function"><h3><a name="ser_resolve_subst_ptr">void * ser_resolve_subst_ptr(ser_job_t * job, const size_t hi,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * tag, const size_t ai,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char ** type, bool * ref)</a></h3></span>
<p class="funcdesc">Returns a pointer to the start of field <strong>tag</strong> (array offset <strong>ai</strong>) in the structure held by holder index <strong>hi</strong> in <strong>job</strong>. Returns NULL if it cannot be found. <br/><br/> If <strong>type</strong> is provided the pointer at that location will be pointed to a string with the type of the destination. This is in use somewhere else in the program and should not be freed. <br/><br/> If <strong>ref</strong> is provided it will be set to true if the resolved address points to a reference field or false if it is a normal value or the beginning of a struct (possibly anonymous).</p>
<span class="function"><h3><a name="ser_check_subst_ptrs">bool ser_check_subst_ptrs(ser_job_t * job)</a></h3></span>
<p class="funcdesc">Checks that all substitution pointers in <strong>job</strong> resolve to valid locations (the holder, field and array index (if >0) must exist).</p>
<span class="function"><h3><a name="ser_add_subst_ptr">ser_subst_ptr_t * ser_add_subst_ptr(ser_job_t * job, const size_t d_hi,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * d_tag, const size_t d_ai)</a></h3></span>
<p class="funcdesc">Creates a new substitution pointer structure in <strong>job</strong>. When dereferenced, the subst pointer will resolve to holder[@d_hi@].@d_tag@[@d_ai@]. Any pointer that wants to use this location should point themselves at the structure returned.</p>
<span class="function"><h3><a name="ser_restore_pointers">bool ser_restore_pointers(ser_job_t * job)</a></h3></span>
<p class="funcdesc">Goes through every structure held by <strong>job</strong> and resolves reference indices to real pointers. <br/><br/> For example, any reference to #2 will be replaced by the address in holder[2]->start. <br/><br/> Returns true on success, false on failure.</p>
<span class="function"><h3><a name="ser_restore_ptr">bool ser_restore_ptr(ser_job_t * job, ser_holder_t * holder,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ser_tra_t * tra, ser_field_t * field)</a></h3></span>
<p class="funcdesc">Resolves the destination holder for a substitution pointer structure located at <strong>field</strong> in <strong>holder.</strong> <strong>tra</strong> should be the translator for <strong>holder</strong>. If <strong>tra</strong> or <strong>field</strong> is an array all elements will be processed. <br/><br/> Returns true on success, false on failure.</p>
<span class="function"><h3><a name="ser_replace_ptr">void * ser_replace_ptr(ser_job_t * job,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const size_t holder_index,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char * tag)</a></h3></span>
<p class="funcdesc">Returns a pointer to field <strong>tag</strong> in the structure held by holder <strong>holder_index</strong> in <strong>job</strong>; NULL if no such field could be found (it's missing in the <strong>id</strong> translator) or any other error occurs.</p>
<span class="function"><h3><a name="ser_read_struct">bool ser_read_struct(ser_job_t * job, const long id, ser_tra_t * thing_tra)</a></h3></span>
<p class="funcdesc">Reads a structure from <strong>job</strong>s input buffer and assigns it to holder <strong>id</strong>. The structure will be parsed according to <strong>thing_tra</strong>. <br/><br/> Returns true on success, false on error.</p>
<span class="function"><h3><a name="ser_read_struct_internal">bool ser_read_struct_internal(ser_job_t * job, ser_holder_t * holder,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ser_tra_t * thing_tra, void * ptr)</a></h3></span>
<p class="funcdesc">Assumes <strong>job</strong>s input parsing is at the start of a structure (after the opening brace). Reads the structure into <strong>ptr</strong> according to <strong>thing_tra</strong>. If <strong>holder</strong> is non-NULL, it will be used to reallocate ptr (if needed; this is only used for dynamic arrays - do not pass it when reading static arrays or embedded structs). <br/><br/> Returns true on success, false on error.</p>
<span class="function"><h3><a name="ser_expect">bool ser_expect(ser_job_t * job, ser_tok_t expected)</a></h3></span>
<p class="funcdesc">Reads a token from <strong>job</strong>s input buffer. Returns true if it is of type <strong>expected</strong>, otherwise false. If it is of another type a message will be sent to <strong>job</strong>s log_func. The output will be discarded (this is mostly useful for detecting braces and terminators).</p>
<span class="function"><h3><a name="ser_read_value">bool ser_read_value(ser_job_t * job, const char * type, ser_tok_t r,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * where, char * token, long int value)</a></h3></span>
<p class="funcdesc">Reads <strong>token</strong> into <strong>where.</strong> <strong>r</strong> is the type of token provided and must match the <strong>field.</strong> If the field is a numeric <strong>value</strong> will be used instead of <strong>token.</strong> <br/><br/> Returns true on success, false on failure.</p>
<span class="function"><h3><a name="ser_ntok">ser_tok_t ser_ntok(ser_job_t * job, char ** dest, long int * value)</a></h3></span>
<p class="funcdesc">Extracts a new token from <strong>job</strong>s parse buffer. Returns the type of token, ser_tok_any if it can't determine what it is. <strong>dest</strong> will be repointed to the string representation of the token. <strong>value</strong> will be set to the numerical value, if it can be determined. <br/><br/> On error, ser_tok_err is returned and a message will be printed using the log_func of <strong>job.</strong> In these cases, it is usually not necessary to print any other error messages.</p>
<span class="function"><h3><a name="ser_field_by_offset">ser_field_t * ser_field_by_offset(ser_tra_t * tra, const size_t offset)</a></h3></span>
<p class="funcdesc">Returns the field in <strong>tra</strong> with offset <strong>offset</strong>, or NULL if none is found.</p>
<span class="function"><h3><a name="ser_blank_struct">void * ser_blank_struct(ser_tra_t * tra)</a></h3></span>
<p class="funcdesc">Allocates and blanks memory for a structure of type <strong>tra</strong>.</p>
<span class="function"><h3><a name="ser_token_code">char * ser_token_code(const ser_tok_t token)</a></h3></span>
<p class="funcdesc">Returns a pointer to a string describing <strong>token.</strong></p>
</body>
</html>